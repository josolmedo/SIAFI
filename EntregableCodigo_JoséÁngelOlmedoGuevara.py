# -*- coding: utf-8 -*-
"""Origin_Space.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l0kk2n5Af10cExbuKDhPT44MGnRp-EZP
"""

import heapq #Importamos biblioteca para manejar colas (estructura de dato)

def a_estrella_busqueda(grafo, inicio, destino):
  '''Función que permite realizar una búsqueda dentro de un grafo  dado un
  nodo de inicio y uno de destino empleando el algoritmo A*'''
  no_explorado = []  # Creamos una lista de los nodos que aún no han sido explorados
  explorados = set()  # Creamos un conjunto de de los nodos ya visitados
  camino = {}  # Diccionario que nos dirá los nodos que recorrimos

    # Iniciando el recorrio con el primer nodo
  heapq.heappush(no_explorado, (0, inicio)) #Agregar un nodo a la cola, la tupla representa '0' el costo de inicio y 'start' el nodo de inicio.
  camino[inicio] = None #El diccionario en un inicio no tendrá un camino recorrido por lo que lo pondremos vacío con el nodo de inicio.
  distancia = {nodo: float('inf') for nodo in grafo}
  '''Generamos un diccionario en donde todas las claves sean todos los nodos existentes, incializamos todos
  los valores en infinito, posteriormente lo modificaremos dependiendo de las distancias de cada nodo.'''

  distancia[inicio] = 0 #La distancia del nodo de inicio será cero.

  while no_explorado: #Ciclo para recorrer los nodos sin explorar
      costo_actual, nodo_actual = heapq.heappop(no_explorado)
      '''De mi estructura de datos, extraemos el primer nodo no explorado,
      extraemos el coste actual y cual es ese nodo'''

      if nodo_actual == destino: #Si el nodo actual es el nodo al que queremos llegar
          return formar_camino(camino, inicio, destino) #Reconstruimos el camino FIN DEL CICLO

      explorados.add(nodo_actual) #Agregamos al conjunto de nodos explorados al nodo actual

      for nodo_vecino, coste in grafo[nodo_actual].items(): #Ciclo para iterar en cada uno de los nodos vecinos y su coste en el grafo
          if nodo_vecino in explorados: #Si el nodo vecino se encuentra en la lista de nodos  ya explorados
              continue #Decidimos continuar

          distancia_tentativa = distancia[nodo_actual] + coste #Calculamos la distancia acumulada desde el nodo de inicio hasta el nodo actual.

          if distancia_tentativa < distancia[nodo_vecino]:
            '''Verifica si la distancia tentativa es menor que la distancia acumulada desde el nodo de inicio hasta el nodo vecino'''
            distancia[nodo_vecino] = distancia_tentativa
            '''Si la distancia tentativa es menor, actualiza la distancia acumulada conocida para el vecino'''
            funcion_a_estrella = distancia_tentativa + heuristica(nodo_vecino, destino)
            '''Obtenemos f(x) para sumando la distancia acumulada tentativa y una heurística que estima la distancia restante hasta el destino'''
            heapq.heappush(no_explorado, (funcion_a_estrella, nodo_vecino))
            '''Agrega el otro vecino que aún no ha sido explorado a la cola (lista) con la nuevo coste calculado (función_a_estrella)'''
            camino[nodo_vecino] = nodo_actual #Actualizamos el camino recorrido dado el nodo actual

  return None  # Si nada de lo anterior funciona, significa que no se encontró ruta

def formar_camino(camino, nodo_inicial, destino): #Función para devolver el camino de los nodos que visitamos para llegar al destino.
  '''Toma como argumentos el diccionario de los nodos recorridos, el nodo de inicio y el nodo destino'''
  nodo_actual = destino #Inicializamos el nodo actual como el nodo destino (ya llegamos al destino)
  ruta = [] #Lista vacía que almacenará los nodos que forman el camino.

  while nodo_actual is not None:  #Ciclo que iterará hasta que el nodo actual este vacío
    ruta.insert(0, nodo_actual) #Insertamos en la primera posición de la lista el nodo actual.
    nodo_actual = camino[nodo_actual]
    ''' Actualiza el nodo actual con el valor almacenado en el diccionario 'camino' para el nodo actual y así recorreremos los nodos visitados'''

  return ruta #Regresamos la ruta

def heuristica(nodo, destino):
  #La heurística en este caso será la distancia auclidana entre las posiciones de ambos nodos.
  return abs(nodo[0] - destino[0]) + abs(nodo[1] - destino [1])

# Ejemplo de uso
grafo = { #Este grafo es un diccionario en donde cada clave es el grafo y los valores son los los nodos vecinos con sus respectivos pesos
    (0, 0): {(0, 1): 1, (1, 0): 2},
    (0, 1): {(0, 0): 1, (1, 1): 1},
    (1, 0): {(0, 0): 1, (1, 1): 1},
    (1, 1): {(0, 1): 1, (1, 0): 1}
}

inicio = (0, 0) #El nodo de inicio será el (0,0)
destino = (1, 1) #El nodo de destino será el (1,1)

prueba = a_estrella_busqueda(grafo, inicio, destino) #Probamos el algoritmo
print(prueba) #Imprimimos la prueba

def dfs(grafo, inicio, destino): #Función para implementar el algoritmo DFS
  pila = [(inicio, [inicio])]  # Pila de nodos por visitar y camino seguido
  '''Haremos uso de una estructura de datos conocida como pila, recibe tuplas,
  el primer elemento contendra un nodo y el segundo será el camino hacia ese nodo. '''
  visitados = set()  # Conjunto de nodos visitados, no se pueded modificar.

  while pila: #Bucle para iterar mientras haya nodos en la pila.
    (nodo_actual, camino) = pila.pop() #Desapilamos el nodo actual y el camino hasta a ese nodo

    if nodo_actual in visitados: #Si ese nodo ya ha sido visitado
      continue #Saltamos a la siguiente iteración

    visitados.add(nodo_actual) #Sino, añadimos al conjunto de nodos visitados el nodo actual

    if nodo_actual == destino: #Si el nodo actual es el nodo objetivo al que queremos llegar
      return camino #Regresaremos el camino, es decir, todos los nodos por los que pasamos (claves del diccionario)

    '''Aquí comienza la exploración de mis nodos vecinos'''
    for nodo_vecino in grafo[nodo_actual]: #Para cada nodo vecino (valor) de mi grafo en el nodo actual
      '''Ciclo para recorrer mis nodos vecinos'''
      pila.append((nodo_vecino, camino + [nodo_vecino]))
      #Añadiremos a la pila, el nodo vecino y camino para llegar a él desde mi nodo actual

  return None  #Sino hay alguna ruta no devolveremos nada.

'''El grafo será un diccionario en donde las claves son el nodo y los valores los nodos vecinos'''
grafo = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F', 'G'],
    'D': ['B'],
    'E': ['B', 'H'],
    'F': ['C', 'I', 'J'],
    'G': ['C'],
    'H': ['E'],
    'J': ['K']
}

nodo_de_inicio = 'A' #Nodo de inicio presente
nodo_objetivo = 'K' #Nodo objetivo o final

resultado = dfs(grafo, nodo_de_inicio, nodo_objetivo) #Probamos el algoritmo
print(resultado) #Mostramos el resultado